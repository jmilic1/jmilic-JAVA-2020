package hr.fer.zemris.java.hw06.crypto;

/**
 * Simple class which offers transformations from a byte array into a
 * hexadecimal String representation and from a hexadecimal String
 * representation into a byte array.
 * 
 * @author Jura MiliÄ‡
 *
 */
public class Util {
	/**
	 * Reads given String and generates it's byte equivalent. Method takes each
	 * character and tries to read it as a hexadecimal digit.
	 * 
	 * @param keyText given String
	 * @return Generated byte
	 * @throws IllegalArgumentException if keyText has an odd number of characters
	 *                                  or String contains an invalid hexadecimal
	 *                                  digit
	 */
	public static byte[] hextobyte(String keyText) {
		if (keyText.length() == 0)
			return new byte[0];

		if (keyText.length() % 2 == 1)
			throw new IllegalArgumentException();

		keyText = keyText.toLowerCase();
		byte[] bytes = new byte[keyText.length() / 2];

		for (int i = 0; i < keyText.length(); i += 2) {
			bytes[i / 2] = (byte) (readByteValue(keyText.charAt(i)) << 4);
			bytes[i / 2] += readByteValue(keyText.charAt(i + 1));
		}
		return bytes;
	}

	/**
	 * Transforms given array of bytes into its String equivalent. Method takes both
	 * halves of each byte and generates it's corresponding hexadecimal digit
	 * character.
	 * 
	 * @param bytearray given byte array
	 * @return generated String
	 * @throws IllegalArgumentException if byte could not be generated into a String
	 */
	public static String bytetohex(byte[] bytearray) {
		String str = "";

		for (int i = 0; i < bytearray.length; i++) {
			byte currentByte = bytearray[i];

			str += generateString((byte) (currentByte >> 4));
			str += generateString((byte) (currentByte & 0x0F));
		}
		return str;
	}

	/**
	 * Generates a String representative of given byte. Value of byte must be in
	 * range [-8,15];
	 * 
	 * @param digit given byte
	 * @return generated String
	 * @throws IllegalArgumentException if byte is not in range
	 */
	private static String generateString(byte digit) {
		if (digit >= 0 && digit < 10)
			return String.valueOf(digit);

		switch (digit) {
		case (-8):
			return "8";
		case (-7):
			return "9";
		case (-6):
		case (10):
			return "a";
		case (-5):
		case (11):
			return "b";
		case (-4):
		case (12):
			return "c";
		case (-3):
		case (13):
			return "d";
		case (-2):
		case (14):
			return "e";
		case (-1):
		case (15):
			return "f";
		}
		throw new IllegalArgumentException();
	}

	/**
	 * Reads a given character and generates it's byte representation.
	 * 
	 * @param c given character
	 * @return generated byte
	 * @throws IllegalArgumentException if character is not a digit nor is it one of
	 *                                  the letters [a-f]
	 */
	private static byte readByteValue(char c) {
		if (Character.isDigit(c)) {
			return (byte) Character.digit(c, 10);
		}
		switch (c) {
		case ('a'):
			return 10;
		case ('b'):
			return 11;
		case ('c'):
			return 12;
		case ('d'):
			return 13;
		case ('e'):
			return 14;
		case ('f'):
			return 15;
		}
		throw new IllegalArgumentException();
	}
}
