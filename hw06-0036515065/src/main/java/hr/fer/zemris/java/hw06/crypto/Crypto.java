package hr.fer.zemris.java.hw06.crypto;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Scanner;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Program which can encrypt, decrypt and check an SHA digest of files. Program
 * can check if user-given digest is equal to SHA digest generated by inputing
 * given file. Program can also encrypt/decrypt given file into a new file.
 * 
 * @author Jura MiliÄ‡
 */
public class Crypto {
	/**
	 * Maximum number of bytes that should be read at a time.
	 */
	private static final int READ_BYTES = 4000;

	/**
	 * The start of program. Valid arguments are "checksha <file-name>", "encrypt
	 * <input-file> <output-file>" and "decrypt <input-file> <output-file>". Encrypt
	 * and decrypt generate output file if it does not exist. If program should
	 * check SHA digest, it will ask the user to type into console an expected
	 * digest and check if two digests are equal. If program should encrypt or
	 * decrypt a file, it will ask the user for a password and an initialization
	 * vector.
	 * 
	 * @param args arguments of program which dictate what the program should do
	 */
	public static void main(String[] args) {
		try (Scanner reader = new Scanner(System.in)) {
			if (args[0].equals("checksha")) {
				System.out.printf("Please provide expected sha-256 digest for hw06test.bin:\n> ");
				String given = reader.nextLine();
				compareDigest(args[1], given);
			} else {
				System.out.printf("Please provide password as hex-encoded text (16 bytes, i.e. 32 hex-digits):\n> ");
				String keyText = reader.nextLine();

				System.out.printf("Please provide initialization vector as hex-encoded text (32 hex-digits):\n> ");
				String ivText = reader.nextLine();

				SecretKeySpec keySpec = new SecretKeySpec(Util.hextobyte(keyText), "AES");
				AlgorithmParameterSpec paramSpec = new IvParameterSpec(Util.hextobyte(ivText));

				useCipher(args, keySpec, paramSpec);
			}
		}
	}

	/**
	 * Creates an enrypted/decrypted file using AES algorithm based on given String
	 * arguments. The only legal values for the first String argument are "encrypt"
	 * and "decrypt". The second String argument is source file name, and the third
	 * one is destination file name. File is encrypted/decrypted based on given
	 * SecretKey and AlgorithmParameter
	 * 
	 * @param args      given String arguments
	 * @param keySpec   given SecretKey
	 * @param paramSpec given AlgorithmParameter
	 */
	private static void useCipher(String[] args, SecretKeySpec keySpec, AlgorithmParameterSpec paramSpec) {
		Cipher cipher = null;
		try {
			cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			cipher.init(args[0].equals("encrypt") ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, keySpec, paramSpec);
		} catch (Exception ex) {
			System.out.println("Unable to initialize cipher");
			System.exit(-1);
		}

		try (FileInputStream is = new FileInputStream(args[1]);
				FileOutputStream os = new FileOutputStream(new File(args[2]));) {
			byte[] buffer = new byte[READ_BYTES];
			int space = 0;

			while (is.available() > 0) {
				space = is.read(buffer);
				os.write(cipher.update(buffer, 0, space));
			}
		} catch (Exception ex) {
			System.out.println("Could not finish encryption/decryption");
			System.exit(-1);
		}

		String str = (args[1].equals("encrypt") ? "Encryption" : "Decryption");
		System.out.println(str + " completed. Generated file " + args[2] + " based on file " + args[1]);
	}

	/**
	 * Computes the SHA digest of given file, compares it to given String and
	 * outputs a message accordingly.
	 * 
	 * @param name  name of given file
	 * @param given given String
	 */
	private static void compareDigest(String name, String given) {
		try {
			MessageDigest sha = MessageDigest.getInstance("SHA-256");

			try (FileInputStream is = new FileInputStream(new File(name))) {
				byte[] buffer = new byte[READ_BYTES];

				while (true) {
					int r = is.read(buffer);
					if (r < 1)
						break;
					sha.update(buffer, 0, r);
				}
			} catch (IOException ex) {
				System.out.println("Unable to make digest of file");
				System.exit(-1);
			}

			String strOutput = Util.bytetohex(sha.digest());

			if (strOutput.equals(given)) {
				System.out.println("Digesting completed. Digest of " + name + " matches expected digest.");
			} else
				System.out.printf("Digesting completed. Digest of " + name
						+ " does not match the expected digest. Digest was: " + strOutput);
		} catch (NoSuchAlgorithmException ex) {
			System.out.println("Could not find algorithm for digest.");
			System.exit(-1);
		}
	}
}
